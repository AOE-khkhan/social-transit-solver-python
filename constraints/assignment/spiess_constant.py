"""Python implementation of the constant-cost Spiess and Florian model.

Based on the constant-cost version of the transit assignment model from
"H. Spiess and M. Florian. Optimal Strategies: A New Assignment Model for
Transit Networks. Transportation Research Part B: Methodological,
23B(2):83-102, 1989."

While this model can potentially be used by itself as a transit assignment
model, its main purpose is to act as a subroutine for the nonlinear cost
version.
"""

import cplex as cp
import numpy as np

#==============================================================================
class SpiessConstant:
    """The main public class for the constant-cost Spiess module.

    The purpose of this class is to create an object capable of maintaining and
    updating the problem data, applying the constant-cost Spiess and Florian
    model to the given network, and outputting an arc flow vector. It can
    potentially be used directly from the constraints module, but is really
    meant to be used by the nonlinear Spiess module as a subroutine.
    """

    #--------------------------------------------------------------------------
    def __init__(self, data="", cplex_epsilon=0.001):
        """Constant-cost Spiess object constructor.

        Automatically reads in the network data and initializes the CPLEX
        solver for use in solving the constant-cost Spiess and Florian model.

        Accepts the following optional keyword arguments:
            data -- Root directory containing the network information. Defaults
                to the current working directory.
            cplex_epsilon -- Epsilon value for CPLEX solver's cleanup method.
                Values generated by the solver falling below this absoulte
                value are deleted between solves. Defaults to 0.001.
        """

        self.data = data
        self.epsilon = cplex_epsilon

        # Load node, arc, and OD data
        self._load_nodes()
        self._load_arcs()
        self._load_od()

        # Initialize Cplex object to define the Spiess and Florian model LPs
        self._cplex_setup()

    #--------------------------------------------------------------------------
    def __del__(self):
        """Constant-cost Spiess object destructor. Closes the CPLEX solver."""

        self.lp.end()

    #--------------------------------------------------------------------------
    def _load_nodes(self):
        """Loads node data from data file.

        Creates a list of node objects, sets their internal attributes, and
        creates lists of specific node types for use in interacting with the
        CPLEX solver.
        """

        # Initialize node lists
        self.nodes = [] # node objects for every node
        self.destinations = [] # node objects for destinations only
        self.stops = [] # node objects for stops only

        # Populate node lists
        i = 0
        with open(self.data+"Nodedata_Con.txt", 'r') as f:
            for line in f:
                i += 1
                if i > 1:
                    # Skip comment line
                    dum = line.split()
                    # Initialize a new node
                    self.nodes.append(_Node(NodeID=int(dum[0]),
                                            NodeType=int(dum[1]),
                                            Line=int(dum[2])))
                    if int(dum[1]) == 1:
                        # Add a new destination node to the destination list
                        self.destinations.append(self.nodes[-1])
                    if int(dum[1]) == 2:
                        # Add new stop node to the stop list
                        self.stops.append(self.nodes[-1])

    #--------------------------------------------------------------------------
    def _load_arcs(self):
        """Loads arc data from data file.

        Creates a list of arc objects, sets their internal attributes, and
        creates lists of specific arc types for use in interacting with the
        CPLEX solver.

        We also calculate the total travel time for a complete circuit of each
        line, which is required for calculating the average waiting time for a
        given solution.
        """

        # Initialize arc list
        self.arcs = [] # arc objects for every arc
        self.boarding = [] # boarding arc objects

        # Populate arc lists
        i = 0
        with open(self.data+"Arcdata_Con.txt", 'r') as f:
            for line in f:
                i += 1
                if i > 1:
                    # Skip comment line
                    dum = line.split()
                    # Initialize a new arc
                    self.arcs.append(_Arc(ArcID=int(dum[0]),
                                          ArcType=int(dum[1]),
                                          Line=int(dum[2]),
                                          Out=int(dum[3]),
                                          In=int(dum[4]),
                                          TrTime=float(dum[5])))

        # Create arc list structures
        for a in self.arcs:
            # Add arc to its head's in-list and its tail's out-list
            self._get_node(a.head).in_arcs.append(a.index)
            self._get_node(a.tail).out_arcs.append(a.index)
            if a.type == 1:
                # Add boarding arc to line boarding arc list
                self.boarding.append(a)
                # Add waiting variable and constraint to arc
                a.var = self._var_name(a.tail, flow=False)
                a.con = self._con_name(a.tail, a.index)

    #--------------------------------------------------------------------------
    def _load_od(self):
        """Loads OD travel demands from data file.

        Creates an array with one row for each node and one column for each
        destination node. Element [i][j] indicates the travel demand from node
        i to node j.
        """

        # Initialize OD matrix
        self.od = [[0 for j in self.destinations] for i in self.nodes]

        # Populate OD matrix
        i = 0
        with open(self.data+"ODdata.txt", 'r') as f:
            for line in f:
                i += 1
                if i > 1:
                    # Skip comment line
                    dum = line.split()
                    (self.od[int(dum[1])]
                    [self._destination_index(int(dum[2]))]) = int(dum[3])

        # Set each destination's own travel demand to the negative total
        # (required to satisfy flow conservation constraints)
        for i in range(len(self.destinations)):
            total = 0
            for j in range(len(self.nodes)):
                total += self.od[j][i]
            self.od[self.destinations[i].index][i] = -total

    #--------------------------------------------------------------------------
    def _cplex_setup(self):
        """Initializes the Cplex object and defines the constant-cost model.

        The LP here concerns a transit network G = (V,E) for which we want to
        calculate all arc flows. This problem can be separated by destination
        node. For any destination node r, the corresponding LP is:

            min  sum_{ij in E} c_ij v_ij + sum_{i in V} w_i
            s.t. sum_{ij:ij in E} v_ij - sum_{ji:ji in E} v_ji = D_ir
                                                 for all i in V
                 v_ij - f_ij w_i <= 0        for all ij:ij in E, for all i in V
                 v_ij >= 0                   for all ij in E

        The parameters here are c_ij (cost of arc ij), f_ij (frequency of arc
        ij), and D_ir (travel demand from i to r). The variables are v_ij
        (total flow on arc ij) and w_i (total waiting time at node i). Note
        that nodes not subject to waiting require no waiting time variables or
        constraints.

        The Cplex object created here will only correspond to the data from one
        destination at a time. To change destinations, the RHS of the flow
        conservation constraints must be updated with the new travel demands.
        """

        dest = self.destinations[0].index # initialize for first destination

        # Initialize Cplex object
        self.lp = cp.Cplex()

        # Silence the CPLEX output streams
        self.lp.set_log_stream(None)
        self.lp.set_results_stream(None)
        self.lp.set_error_stream(None)
        self.lp.set_warning_stream(None)

        # Set LP as minimization
        self.lp.objective.set_sense(self.lp.objective.sense.minimize)

        # Variable names
        flow_vars = [self._var_name(a.index, flow=True) for a in self.arcs]
        wait_vars = [self._var_name(n.index, flow=False) for n in self.stops]

        # Objective coefficients are travel times for flows and 1 for waits
        flow_obj = [a.cost for a in self.arcs]
        wait_obj = [1.0 for n in self.stops]

        # All variables are nonnegative with no fixed upper bound
        flow_lb = [0.0 for a in self.arcs]
        flow_ub = [cp.infinity for a in self.arcs]
        wait_lb = [0.0 for n in self.stops]
        wait_ub = [cp.infinity for n in self.stops]

        # Define LP variables, bounds, and objective coefficients
        self.lp.variables.add(names=flow_vars+wait_vars, obj=flow_obj+wait_obj,
                              lb=flow_lb+wait_lb, ub=flow_ub+wait_ub)

        # Constraint names
        flow_con = [self._con_name(n.index) for n in self.nodes]
        wait_con = []
        for n in self.stops:
            wait_con += [self._con_name(n.index, a) for a in n.out_arcs]

        # Senses are '==' for flow conservation and '<=' for waiting
        flow_sense = "E"*len(flow_con)
        wait_sense = "L"*len(wait_con)

        # RHS of is (i,r) flow demand for flow conservation and 0 for wait time
        flow_rhs = [self.od[i][self._destination_index(dest)] for i in
                    range(len(self.nodes))]
        wait_rhs = [0.0 for i in range(len(wait_con))]

        # Define flow conservation constraints by iterating through each node
        flow_lin_expr = [[[], []] for n in self.nodes]
        for i in range(len(self.nodes)):
            # Outgoing arc variable names
            var_out = [self._var_name(a, flow=True) for a in
                       self.nodes[i].out_arcs]
            # Incoming arc variable names
            var_in = [self._var_name(a, flow=True) for a in
                      self.nodes[i].in_arcs]
            # Coefficient 1 for outgoing and -1 for incoming
            coef = [1 for i in var_out] + [-1 for i in var_in]
            # Update linear expression
            flow_lin_expr[i] = [var_out+var_in, coef]

        # Define waiting time constraints for each node's out-arcs
        wait_lin_expr = [[["", ""], [1, -1]] for i in range(len(wait_con))]
        i = -1
        for n in self.stops:
            for a in n.out_arcs:
                i += 1
                # Update linear expression
                wait_lin_expr[i][0] = [self._var_name(a, flow=True),
                             self._var_name(n.index, flow=False)]

        # Define LP constraints
        self.lp.linear_constraints.add(names=flow_con,
                                       lin_expr=flow_lin_expr,
                                       senses=flow_sense,
                                       rhs=flow_rhs)
        self.lp.linear_constraints.add(names=wait_con,
                                       lin_expr=wait_lin_expr,
                                       senses=wait_sense,
                                       rhs=wait_rhs)

    #--------------------------------------------------------------------------
    def _get_node(self, index):
        """Returns a pointer to the node object with the given node ID."""

        node = None
        for n in self.nodes:
            if n.index == index:
                node = n
                break
        return node

    #--------------------------------------------------------------------------
    def _destination_index(self, index):
        """Returns the position of a given node index in the dest node list."""

        pos = -1
        for i in range(len(self.destinations)):
            if index == self.destinations[i].index:
                pos = i
                break
        return pos

    #--------------------------------------------------------------------------
    def _var_name(self, index, flow=True):
        """Template for generating variable names.

        Accepts an index and (optionally) a boolean indicating whether this is
        a flow variable. If True, then the variable name is 'v' with an arc ID.
        If False, then this is a waiting time variable named 'w' with a node
        ID.
        """

        if flow == True:
            # Flow through arc
            return "v("+str(index)+")"
        else:
            # Waiting time at node
            return "w("+str(index)+")"

    #--------------------------------------------------------------------------
    def _con_name(self, *args):
        """Template for generating constraint names.

        Accepts one or two indices. If one index, we assume this to be the flow
        conservation constraint at a node, called 'c' with the node's ID. If
        two, we assume this to be the waiting time constraint for an arc at a
        node, called 't' with the node's ID followed by the arc's ID.
        """

        if len(args) == 1:
            # Flow conservation at node
            return "c("+str(args[0])+")"
        if len(args) == 2:
            # Waiting time for boarding arc at stop node
            return "t("+str(args[0])+","+str(args[1])+")"

    #--------------------------------------------------------------------------
    def _cplex_solve(self, add=False):
        """Solves the current Cplex model and updates the node/arc attributes.

        The solution is loaded into the node and arc objects directly, with the
        flow variables assigned to the corresponding arcs and the waiting times
        assigned to the corresponding nodes.

        Accepts the following optional keyword arguments:
            add -- Whether to add the current results to the node/arc objects'
                current waiting/flow values. Defaults to False, in which case
                these values are overwritten. If set to True, the new solution
                values are added to the previous values. This is meant for use
                in the process of summing all destination-specific values to
                find only the totals.
        """

        self.lp.cleanup(self.epsilon) # clean up solver leftovers
        self.lp.solve() # have CPLEX solve the LP

        # Read results from the CPLEX solution
        for a in self.arcs:
            if add == False:
                a.flow = self.lp.solution.get_values(self._var_name(a.index,
                      flow=True))
            else:
                a.flow += self.lp.solution.get_values(self._var_name(a.index,
                      flow=True))
        for n in self.stops:
            if add == False:
                n.wait = self.lp.solution.get_values(self._var_name(n.index,
                      flow=False))
            else:
                n.wait += self.lp.solution.get_values(self._var_name(n.index,
                      flow=False))

    #--------------------------------------------------------------------------
    def _set_destination(self, dest):
        """Updates the Cplex model to correspond to a different destination.

        This involves resetting the RHS of the flow conservation constraints to
        reflect the destination's OD travel demand.
        """

        # The Cplex RHS reset requires a list of (name,value) tuples
        new_rhs = [(self._con_name(self.nodes[i].index), self.od[i][dest]) for
                   i in range(len(self.nodes))]
        self.lp.linear_constraints.set_rhs(new_rhs)

    #--------------------------------------------------------------------------
    def update_lines(self, freq, *cap):
        """Updates the Cplex object for a new line frequency vector.

        Each solution produced by the main search algorithm defines a frequency
        and capacity for each line. These are calculated within the constraint
        module and can be passed directly to this solver. The update process
        requires changing the waiting time coefficients in the waiting time
        constraints.

        Note that the optional second argument is simply a placeholder and is
        not used for any calculations. It is there because the nonlinear model
        requires both frequency and capacity updates for each new solution, and
        switching from one module to the other will be easier if they can both
        use the same method names and argument formats.
        """

        # The Cplex coefficient reset requires a list of (con,var,val) triples
        # The constraint and variable names are stored in the arc
        # The new frequency is the arc's corresponding line's entry
        new_coef = [(a.con, a.var, -freq[a.line]) for a in self.boarding]
        self.lp.linear_constraints.set_coefficients(new_coef)

    #--------------------------------------------------------------------------
    def update_cost(self, cost):
        """Updates the Cplex object for a new arc cost vector.

        This is required for the nonlinear model's solution process, which
        involves iteratively solving and re-solving the fixed-cost version with
        different cost vectors. The update process requires changing the flow
        variable coefficients in the objective.
        """

        # The Cplex coefficient reset requires a list of (var,value) tuples
        new_coef = [(self._var_name(self.arcs[i].index, flow=True), cost[i])
                    for i in range(len(cost))]
        self.lp.objective.set_linear(new_coef)

    #--------------------------------------------------------------------------
    def calculate(self):
        """Solves the Cplex model for all dests and outputs the total results.

        This involves cycling the model through every destination node and
        summing the flows and waiting times from each.

        The output is a tuple consisting of a NumPy array of total arc flows
        (in the order of the arc list) and the total waiting time (as a
        scalar), respectively.
        """

        for i in range(len(self.destinations)):
            # Solve the model for each destination
            self._set_destination(i)
            if i == 0:
                # Overwrite values for first iteration
                self._cplex_solve(add=False)
            else:
                # Add values after first iteration
                self._cplex_solve(add=True)

        # Total waiting time
        tot_wait = 0.0
        for n in self.nodes:
            tot_wait += n.wait

        # Return flows followed by waiting time
        return np.array([a.flow for a in self.arcs], dtype=float), tot_wait

#==============================================================================
class _Node:
    """A class for storing node-level attributes."""

    #--------------------------------------------------------------------------
    def __init__(self, NodeID=-1, NodeType=-1, Line=-1):
        """Node object constructor. Initializes node-level attributes.

        Accepts the following optional keyword arguments:
            NodeID -- Node index.
            NodeType -- Node type index.
                0: origin
                1: destination
                2: platform
                3: line
            Line -- Index of associated line.
        """

        self.index = NodeID
        self.type = NodeType
        self.line = Line

        self.wait = 0.0 # waiting time variable value
        self.out_arcs = [] # outgoing arc objects
        self.in_arcs = [] # incoming arc objects

#==============================================================================
class _Arc:
    """A class for storing arc-level attributes."""

    #--------------------------------------------------------------------------
    def __init__(self, ArcID=-1, ArcType=-1, Line=-1, Out=-1, In=-1,
                 TrTime=-1):
        """Arc object constructor. Initializes arc-level attributes.

        Accepts the following optional keyword arguments:
            ArcID -- Arc index.
            ArcType -- Arc type index.
                0:line
                1:boarding
               -1:other
            Line -- Index of associated line.
            Out -- Index of tail node (node which this arc leaves).
            In -- Index of head node (node which this arc enters).
            TrTime -- Travel time for arc.
        """

        self.index = ArcID
        self.type = ArcType
        self.line = Line
        self.tail = Out
        self.head = In
        self.cost = TrTime

        self.flow = 0.0 # flow variable value
        self.con = "" # associated waiting constraint name
        self.var = "" # associated waiting variable name
