"""A module for calculating the gravity-based objective.

The main public class, Objective, includes a variety of methods for calculating
gravity-based accessibility metrics of a set of population centers. Upon
initialization it reads in network data and maintains this information along
with a CPLEX object to recalculate the gravity metrics during each iteration of
the search process.

There are also private classes for storing node and arc data.
"""

import cplex as cp

#==============================================================================
class Objective:
    """A class for calculating the gravity-based objective.

    The object created from this class should be initialized with some basic
    information about the underlying network, and should be updated each
    iteration depending on the current solution. Its main public method uses
    its internal information to output the objective value.
    """

    #--------------------------------------------------------------------------
    def __init__(self, data="", logfile="metrics.txt", friction=1.0,
                 epsilon=0.001, turnaround=[0.0]):
        """Objective object constructor.

        Automatically reads in the network data and initializes the CPLEX
        solver for use in calculating shortest paths.

        Accepts the following optional keyword arguments:
            data -- Root directory containing the network information. Defaults
                to the current working directory.
            logfile -- Output file path. The gravity metric for each population
                center is written to this file at the end of the search.
                Defaults to the current working directory.
            friction -- Travel friction coefficient for the gravity-based
                metric. Defaults to 1.0. This is the value to use for the
                inverse power of pairwise distances. It has no specific
                physical meaning and is simply a tuning parameter, but larger
                values cause faster falloff over distance (and thus effectively
                smaller catchment areas).
            epsilon -- Epsilon value for CPLEX solver's cleanup method. Values
                generated by the solver falling below this absoulte value are
                deleted between solves. Defaults to 0.001.
            turnaround -- Total time required for each route to reset between
                runs (in minutes). This may include a combination of layover
                time and driving back to the route start.
        """

        self.data = data
        self.logfile = logfile
        self.friction = friction
        self.epsilon = epsilon

        # Load node and arc data
        self._load_nodes()
        self._load_arcs()

        # Define Cplex object to define shortest path LP
        self._cplex_setup()

    #--------------------------------------------------------------------------
    def __del__(self):
        """Objective object destructor. Closes the CPLEX solver."""

        self.lp.end()

    #--------------------------------------------------------------------------
    def _load_nodes(self):
        """Loads node data from data file.

        Creates a list of node objects, sets their internal attributes, and
        creates lists of specific node types for use in interacting with the
        CPLEX solver.
        """

        # Initialize node lists
        self.nodes = [] # node objects for every node
        self.origins = [] # node objects for origins only
        self.destinations = [] # node objects for destinations only

        # Populate node lists
        i = 0
        with open(self.data+"Nodedata_Simple.txt", 'r') as f:
            for line in f:
                i += 1
                if i > 1:
                    # Skip comment line
                    dum = line.split()
                    # Initialize a new node
                    self.nodes.append(_Node(NodeID=int(dum[0]),
                                            NodeType=int(dum[1]),
                                            Line=int(dum[2]),
                                            Val=float(dum[3])))
                    if int(dum[1]) == 0:
                        # Add a new origin node to the origin list
                        self.origins.append(self.nodes[-1])
                    if int(dum[1]) == 1:
                        # Add a new destination node to the destination list
                        self.destinations.append(self.nodes[-1])

        # Set variable name and distance lists for origins and destinations
        for s in self.origins:
            s.var = [self._var_name(s.index,n.index)
                     for n in self.destinations]
            s.dist = [0 for n in self.destinations]
        for s in self.destinations:
            s.var = [self._var_name(s.index,n.index) for n in self.origins]
            s.dist = [0 for n in self.origins]

    #--------------------------------------------------------------------------
    def _load_arcs(self):
        """Loads arc data from data file.

        Creates a list of arc objects, sets their internal attributes, and
        creates lists of specific arc types for use in interacting with the
        CPLEX solver.

        We also calculate the total travel time for a complete circuit of each
        line, which is required for calculating the average waiting time for a
        given solution.
        """

        # Initialize arc list
        self.arcs = [] # arc objects for every arc

        # Populate arc lists
        i = 0
        max_line = 0 # maximum line number
        with open(self.data+"Arcdata_Simple.txt", 'r') as f:
            for line in f:
                i += 1
                if i > 1:
                    # Skip comment line
                    dum = line.split()
                    # Initialize a new arc
                    self.arcs.append(_Arc(ArcID=int(dum[0]),
                                          Boarding=bool(int(dum[1])),
                                          Line=int(dum[2]),
                                          Out=int(dum[3]),
                                          In=int(dum[4]),
                                          TrTime=float(dum[5])))
                    max_line = max(max_line, int(dum[2])) # update max line num

        # Create a list of boarding arcs for each line
        self.line_boarding = [[] for i in range(max_line+1)]
        for a in self.arcs:
            if a.boarding == True:
                self.line_boarding[a.line].append(a)

        # Set constraint name lists
        # All constraint names have the form c(s,a), where s takes the value
        # of every possible origin or destination, and a takes the value of
        # every possible arc. Each arc has an associated triangle inequality
        # constraint relating the variables of its two endpoints, and there is
        # a copy of this constraint for every travel origin.
        for a in self.arcs:
            a.cons = [self._con_name(s.index,a.index)
                      for s in self.origins+self.destinations]

        # Calculate a list of total circuit times for each line
        self.line_time = self.turnaround[:] # fixed turnaround time
        for a in self.arcs:
            if a.line >= 0:
                self.line_time[a.line] += a.cost

    #--------------------------------------------------------------------------
    def _cplex_setup(self):
        """Initializes the Cplex object and defines the shortest path LP.

        The LP here concerns a network G = (V,E) for which we want to calculate
        all pairwise distances between the nodes in a subset S of V. The LP
        takes the following form:

            max  sum_{s in S} sum_{t in S} x_st
            s.t. x_sj - x_si <= c_ij            for all s in S, for all ij in E
                 x_ss = 0                       for all s in S

        After solving this LP, x_st will represent the distance from s to t for
        every pair s,t in S. Note that x_si will not in general represent the
        correct distances for nodes i not in S.
        """

        # Initialize Cplex object
        self.lp = cp.Cplex()

        # Silence the CPLEX output streams
        self.lp.set_log_stream(None)
        self.lp.set_results_stream(None)
        self.lp.set_error_stream(None)
        self.lp.set_warning_stream(None)

        # Set LP as maximization
        self.lp.objective.set_sense(self.lp.objective.sense.maximize)

        # Variable names are every possible pair (s,i) from S x V
        var_names = [self._var_name(s.index,n.index) for s in
                     self.origins+self.destinations for n in self.nodes]

        # Objective coefficients are 1 for every origin/destination node and 0
        # otherwise
        var_obj = [0 for i in range(len(var_names))]
        for i in range(len(self.origins+self.destinations)):
            for j in range(len(self.nodes)):
                if (self.nodes[j].type == 0) or (self.nodes[j].type == 1):
                    # change O/D node objectice coefficients to 1
                    var_obj[i*len(self.nodes)+j] = 1

        # Most variables are unbounded, but self-to-self variables are zero
        var_lb = [-cp.infinity for i in range(len(var_names))]
        var_ub = [cp.infinity for i in range(len(var_names))]
        for i in range(len(self.origins+self.destinations)):
            for j in range(len(self.nodes)):
                if ((self.origins+self.destinations)[i].index
                    == self.nodes[j].index):
                    # Change x(s,s) bounds to 0 <= x <= 0
                    var_lb[i*len(self.nodes)+j] = 0
                    var_ub[i*len(self.nodes)+j] = 0

        # Define LP variables, bounds, and objective coefficients
        self.lp.variables.add(names=var_names, obj=var_obj, lb=var_lb,
                              ub=var_ub)

        # Constraint names are every possible pair (s,a) from S x E
        con_names = [self._con_name(s.index,a.index) for s in
                     self.origins+self.destinations for a in self.arcs]

        # All constraints have sense 'L' (for <=)
        con_senses = "L"*len(con_names)

        # Constraint RHS constant is the associated arc's cost
        con_rhs = [a.cost for s in self.origins+self.destinations
                   for a in self.arcs]

        # Each element of the constraint linear expression is a list of two
        # lists, the first of which is a set of variable names and the second
        # of which is the set of corresponding constraints
        con_lin_expr = [[[self._var_name(s.index,a.head),
                         self._var_name(s.index,a.tail)], [1, -1]] for s in
                         self.origins+self.destinations for a in self.arcs]

        # Define LP constraints
        self.lp.linear_constraints.add(names=con_names, lin_expr=con_lin_expr,
                                       senses=con_senses, rhs=con_rhs)

    #--------------------------------------------------------------------------
    def _var_name(self, s, i):
        """Template for generating variable names given two node IDs."""

        return "x("+str(s)+","+str(i)+")"

    #--------------------------------------------------------------------------
    def _con_name(self, s, a):
        """Template for generating constraint names given a node and an arc."""

        return "c("+str(s)+","+str(a)+")"

    #--------------------------------------------------------------------------
    def _update_cplex(self, sol):
        """Updates the Cplex object for a new solution vector.

        The solution vector determines the average headway for each line, which
        in turn determines the cost of each arc. The update process requires us
        to calculate the new headways and then change the corresponding RHS
        constants in the LP.
        """

        self._waiting_time(sol) # update all necessary arc costs

        for i in range(len(sol)):
            for a in self.line_boarding[i]:
                # RHS update requires a list of (name, value) pairs
                rhs_new = [(a.cons[j], a.cost) for j in range(len(a.cons))]
                self.lp.linear_constraints.set_rhs(rhs_new)

    #--------------------------------------------------------------------------
    def _waiting_time(self, sol):
        """Calculates average headway from a solution and updates arcs."""

        for i in range(len(sol)):
            for a in self.line_boarding[i]:
                if sol[i] > 0:
                    # Average headway is total time per total vehicles
                    a.cost = self.line_time[i] / sol[i]
                else:
                    # Zero vehicles means infinite headway
                    a.cost = cp.infinity

    #--------------------------------------------------------------------------
    def _gravity(self):
        """Conducts and returns the gravity calculations for all origin nodes.

        The gravity-based metric is very similar to the 2SFCA metric in that it
        requires first calculating an overcrowding metric for each facility
        which includes a sum of the "nearby" population. The accessibiliy
        metric for a population center is then a sum of all "nearby" facility
        capacities divided by their overcrowding ratios.

        Unlike the 2SFCA model, we do not make use of strict travel time
        cutoffs to decide whether or not locations fall within each others'
        catchment areas. Instead, we use weighted sums that cause the weight of
        a location's term to fall off as an inverse power of distance (hence
        the "gravity" name).

        Specifically, we begin by calculating the weighted population sum for
        each facility j as

            V_j = sum_k P_k (d_kj)^(-beta)

        where the sum is over every population center k, P_k is the population
        at center k, d_kj is distance from k to j, and beta is the time
        friction parameter. The accessibility metric at a population center i
        is then calculated as

            A_i = sum_j {[S_j (d_ij)^(-beta)] / V_j}

        where the sum is over every facility j and S_j is the capacity of
        facility j.
        """

        # Calculate weighted population sum for all destinations
        phys_wt = [0 for i in range(len(self.destinations))]
        for j in range(len(phys_wt)):
            for n in self.origins:
                phys_wt[j] += n.val * n.dist[j]**(-self.friction)

        # Calculate total phys-to-pop ratio for all origins
        access = [0 for i in range(len(self.origins))]
        for i in range(len(access)):
            for j in range(len(phys_wt)):
                access[i] += (self.destinations[j].val *
                      self.origins[i].dist[j]**(-self.friction)) / phys_wt[j]

        return access

    #--------------------------------------------------------------------------
    def calculate(self, sol):
        """Calculates the objective value for a given solution.

        The objective being considered in this problem is to maximize the
        minimum gravity metric over all population centers. However, since the
        main driver is set up to attempt to minimize its objective, this
        method will actually return the negative of the minimum gravity metric.
        """

        return -min(self.metrics(sol))

    #--------------------------------------------------------------------------
    def metrics(self, sol):
        """Calculates a list of gravity metrics for a given solution.

        The metrics are returned as a list with the same order as the
        population center IDs in the Nodedata_Simple.txt file. This method is
        called directly for the final solution to be able to output the final
        list of gravity metrics, but it is also used in the calculate() method
        to calculate the objective value.
        """

        self.lp.cleanup(self.epsilon) # clean up solver leftovers
        self._update_cplex(sol) # update the Cplex object
        self.lp.solve() # have CPLEX solve the LP

        # Read distance results from the CPLEX solution into the node objects
        for n in self.origins+self.destinations:
            n.dist = self.lp.solution.get_values(n.var)

        return self._gravity() # carry out and return the gravity metrics

    #--------------------------------------------------------------------------
    def output(self, sol):
        """Prints the list of all gravity metrics for a solution to a file.

        This should be used to calculate the gravity metrics for the original
        network and then again for the final network after the solution
        algorithm has ended. As part of the results analysis we can compare the
        two to see how much each area has improved.
        """

        metrics = self.metrics(sol) # calculate metrics

        f = open(self.logfile, 'w')
        print("node\tmetric", file=f) # print comment line
        for i in range(len(metrics)):
            print(str(self.origins[i].index)+"\t"+str(metrics[i]), file=f)
        f.close()

#==============================================================================
class _Node:
    """A class for storing node-level attributes."""

    #--------------------------------------------------------------------------
    def __init__(self, NodeID=-1, NodeType=-1, Line=-1, Val=-1):
        """Node object constructor. Initializes node-level attributes.

        Accepts the following optional keyword arguments:
            NodeID -- Node index.
            NodeType -- Node type index.
                0: origin
                1: destination
                2: platform
                3: line
            Line -- Index of associated line.
            Val -- Associated value (population at origin, capacity at
                destination).
        """

        self.index = NodeID
        self.type = NodeType
        self.line = Line
        self.val = Val

        # If this node is an origin or destination, the following two lists
        # will contain the names of all LP variables indicating distance from
        # this node to one in the opposite set, as well as a list of those
        # distance values. Both are ordered in the same way as the origin/
        # destination node sets.
        self.var = []
        self.dist = []

#==============================================================================
class _Arc:
    """A class for storing arc-level attributes."""

    #--------------------------------------------------------------------------
    def __init__(self, ArcID=-1, Boarding=False, Line=-1, Out=-1, In=-1,
                 TrTime=-1):
        """Arc object constructor. Initializes arc-level attributes.

        Accepts the following optional keyword arguments:
            ArcID -- Arc index.
            Boarding -- True for boarding arcs and False otherwise.
            Line -- Index of associated line.
            Out -- Index of tail node (node which this arc leaves).
            In -- Index of head node (node which this arc enters).
            TrTime -- Travel time for arc.
        """

        self.index = ArcID
        self.boarding = Boarding
        self.line = Line
        self.tail = Out
        self.head = In
        self.cost = TrTime

        # Names of associated constraints in the Cplex LP
        self.cons = []
